//! SVG rendering for terminal canvas output.
//!
//! This module provides SVG export functionality similar to Python Textual's
//! rich-terminal SVG output. The generated SVGs are suitable for:
//! - Visual snapshot testing
//! - Documentation screenshots
//! - Web embedding of TUI output

use crossterm::style::Color;
use std::collections::HashMap;
use std::fmt::Write as FmtWrite;

use crate::canvas::{Canvas, TextAttributes};

/// Configuration for SVG rendering.
#[derive(Debug, Clone)]
pub struct SvgConfig {
    /// Title to display in the SVG (optional).
    pub title: Option<String>,
    /// Font family for text rendering.
    pub font_family: String,
    /// Font size in pixels.
    pub font_size: f32,
    /// Line height in pixels.
    pub line_height: f32,
    /// Character width in pixels (for monospace).
    pub char_width: f32,
    /// Whether to include window chrome (rounded corners, etc.).
    pub window_chrome: bool,
    /// Default background color (hex string).
    pub background: String,
}

impl Default for SvgConfig {
    fn default() -> Self {
        Self {
            title: None,
            font_family: "Fira Code, monospace".to_string(),
            font_size: 20.0,
            line_height: 24.4,
            char_width: 12.2,
            window_chrome: false,
            background: "#121212".to_string(),
        }
    }
}

/// SVG renderer for Canvas output.
pub struct SvgRenderer {
    config: SvgConfig,
}

impl SvgRenderer {
    /// Create a new SVG renderer with the given configuration.
    pub fn new(config: SvgConfig) -> Self {
        Self { config }
    }

    /// Render canvas to SVG string.
    pub fn render(&self, canvas: &Canvas) -> String {
        let mut svg = String::new();
        let mut styles = StyleCollector::new();

        // Collect unique styles from canvas
        self.collect_styles(canvas, &mut styles);

        // Build SVG
        self.write_header(&mut svg, canvas);
        self.write_styles(&mut svg, &styles);
        self.write_defs(&mut svg, canvas);
        self.write_content(&mut svg, canvas, &styles);
        self.write_footer(&mut svg);

        svg
    }

    fn collect_styles(&self, canvas: &Canvas, styles: &mut StyleCollector) {
        let (width, height) = canvas.size();
        for y in 0..height as i32 {
            for x in 0..width as i32 {
                let index = (y as usize) * (width as usize) + (x as usize);
                let cell = canvas.cell_at(index);
                if let Some(fg) = cell.fg {
                    styles.add_fg(fg);
                }
                // Background colors use inline hex values, not CSS classes
            }
        }
    }

    fn write_header(&self, svg: &mut String, canvas: &Canvas) {
        let (width, height) = canvas.size();
        let svg_width = (width as f32) * self.config.char_width;
        let svg_height = (height as f32) * self.config.line_height;

        writeln!(
            svg,
            r#"<svg class="rich-terminal" viewBox="0 0 {} {}" xmlns="http://www.w3.org/2000/svg">"#,
            svg_width, svg_height
        )
        .unwrap();
        writeln!(svg, "    <!-- Generated by texrs -->").unwrap();
    }

    fn write_styles(&self, svg: &mut String, styles: &StyleCollector) {
        writeln!(svg, "    <style>").unwrap();

        // Font face definitions
        writeln!(
            svg,
            r#"
    @font-face {{
        font-family: "Fira Code";
        src: local("FiraCode-Regular"),
                url("https://cdnjs.cloudflare.com/ajax/libs/firacode/6.2.0/woff2/FiraCode-Regular.woff2") format("woff2"),
                url("https://cdnjs.cloudflare.com/ajax/libs/firacode/6.2.0/woff/FiraCode-Regular.woff") format("woff");
        font-style: normal;
        font-weight: 400;
    }}
    @font-face {{
        font-family: "Fira Code";
        src: local("FiraCode-Bold"),
                url("https://cdnjs.cloudflare.com/ajax/libs/firacode/6.2.0/woff2/FiraCode-Bold.woff2") format("woff2"),
                url("https://cdnjs.cloudflare.com/ajax/libs/firacode/6.2.0/woff/FiraCode-Bold.woff") format("woff");
        font-style: bold;
        font-weight: 700;
    }}

    .terminal-matrix {{
        font-family: {}, monospace;
        font-size: {}px;
        line-height: {}px;
        font-variant-east-asian: full-width;
    }}"#,
            self.config.font_family, self.config.font_size, self.config.line_height
        )
        .unwrap();

        // Color classes - sorted for deterministic output
        let mut fg_entries: Vec<_> = styles.fg_styles.iter().collect();
        fg_entries.sort_by_key(|(_, class_name)| class_name.as_str());
        for (color, class_name) in fg_entries {
            if let Color::Rgb { r, g, b } = color {
                writeln!(
                    svg,
                    "    .{} {{ fill: #{:02x}{:02x}{:02x} }}",
                    class_name, r, g, b
                )
                .unwrap();
            }
        }

        writeln!(svg, "    </style>").unwrap();
    }

    fn write_defs(&self, svg: &mut String, canvas: &Canvas) {
        let (width, height) = canvas.size();
        let content_width = (width as f32) * self.config.char_width;
        let content_height = (height as f32) * self.config.line_height;

        writeln!(svg, "    <defs>").unwrap();

        // Main clip path
        writeln!(
            svg,
            r#"    <clipPath id="terminal-clip">
      <rect x="0" y="0" width="{}" height="{}" />
    </clipPath>"#,
            content_width, content_height
        )
        .unwrap();

        // Per-line clip paths
        for y in 0..height {
            let y_pos = (y as f32) * self.config.line_height;
            writeln!(
                svg,
                r#"    <clipPath id="terminal-line-{}">
      <rect x="0" y="{}" width="{}" height="{}"/>
    </clipPath>"#,
                y,
                y_pos,
                content_width,
                self.config.line_height + 0.25
            )
            .unwrap();
        }

        writeln!(svg, "    </defs>").unwrap();
    }

    fn write_content(&self, svg: &mut String, canvas: &Canvas, styles: &StyleCollector) {
        writeln!(
            svg,
            r#"    <g transform="translate(0, 0)" clip-path="url(#terminal-clip)">"#
        )
        .unwrap();

        // Write background rectangles
        self.write_backgrounds(svg, canvas);

        // Write text content
        writeln!(svg, "    <g class=\"terminal-matrix\">").unwrap();
        self.write_text(svg, canvas, styles);
        writeln!(svg, "    </g>").unwrap();

        writeln!(svg, "    </g>").unwrap();
    }

    fn write_backgrounds(&self, svg: &mut String, canvas: &Canvas) {
        let (width, height) = canvas.size();

        for y in 0..height as i32 {
            let y_pos = (y as f32) * self.config.line_height;

            // Track runs of same background color
            let mut run_start = 0;
            let mut run_bg: Option<Color> = None;

            for x in 0..=width as i32 {
                let current_bg = if x < width as i32 {
                    let index = (y as usize) * (width as usize) + (x as usize);
                    canvas.cell_at(index).bg
                } else {
                    None // End of line sentinel
                };

                // Check if we need to flush the current run
                if current_bg != run_bg {
                    if let Some(bg) = run_bg {
                        let x_pos = (run_start as f32) * self.config.char_width;
                        let run_width = ((x - run_start) as f32) * self.config.char_width;
                        let color_hex = color_to_hex(&bg);
                        writeln!(
                            svg,
                            r#"    <rect fill="{}" x="{}" y="{}" width="{}" height="{}" shape-rendering="crispEdges"/>"#,
                            color_hex, x_pos, y_pos, run_width, self.config.line_height
                        )
                        .unwrap();
                    }
                    run_start = x;
                    run_bg = current_bg;
                }
            }
        }
    }

    fn write_text(&self, svg: &mut String, canvas: &Canvas, styles: &StyleCollector) {
        let (width, height) = canvas.size();

        for y in 0..height as i32 {
            // Text baseline is below the top of the line
            let y_pos = ((y as f32) + 1.0) * self.config.line_height - 4.0;

            // Track runs of same style
            let mut run_start = 0;
            let mut run_text = String::new();
            let mut run_cells = 0usize;
            let mut run_fg: Option<Color> = None;
            let mut run_attrs = TextAttributes::default();

            for x in 0..=width as i32 {
                let (current_fg, current_attrs, current_symbol, current_continuation, cell_width) =
                    if x < width as i32 {
                        let index = (y as usize) * (width as usize) + (x as usize);
                        let cell = canvas.cell_at(index);
                        (
                            cell.fg,
                            cell.attrs,
                            cell.symbol.as_str(),
                            cell.continuation,
                            cell.width as usize,
                        )
                    } else {
                        (None, TextAttributes::default(), "", false, 0) // End of line sentinel
                    };

                // Check if we need to flush the current run
                let style_changed = current_fg != run_fg || current_attrs != run_attrs;
                if style_changed && !run_text.is_empty() {
                    let x_pos = (run_start as f32) * self.config.char_width;
                    let text_length = (run_cells as f32) * self.config.char_width;
                    let class_name = run_fg
                        .and_then(|fg| styles.fg_styles.get(&fg))
                        .map(|s| s.as_str())
                        .unwrap_or("terminal-default");

                    // Escape XML special characters
                    let escaped_text = escape_xml(&run_text);

                    // Build style attribute for text attributes
                    let mut style_attr = String::new();
                    if run_attrs.bold {
                        style_attr.push_str("font-weight: bold; ");
                    }
                    if run_attrs.italic {
                        style_attr.push_str("font-style: italic; ");
                    }
                    let text_decoration = build_text_decoration(&run_attrs);
                    if !text_decoration.is_empty() {
                        write!(style_attr, "text-decoration: {}; ", text_decoration).unwrap();
                    }

                    let style_part = if style_attr.is_empty() {
                        String::new()
                    } else {
                        format!(r#" style="{}""#, style_attr.trim())
                    };

                    writeln!(
                        svg,
                        r#"    <text class="{}" x="{}" y="{}" textLength="{}"{} clip-path="url(#terminal-line-{})">{}</text>"#,
                        class_name, x_pos, y_pos, text_length, style_part, y, escaped_text
                    )
                    .unwrap();

                    run_text.clear();
                    run_cells = 0;
                }

                if style_changed {
                    run_start = x;
                    run_fg = current_fg;
                    run_attrs = current_attrs;
                }

                if x < width as i32 && !current_continuation {
                    run_text.push_str(current_symbol);
                    run_cells += cell_width;
                }
            }
        }
    }

    fn write_footer(&self, svg: &mut String) {
        writeln!(svg, "</svg>").unwrap();
    }
}

/// Collects and deduplicates color styles.
struct StyleCollector {
    fg_styles: HashMap<Color, String>,
    counter: u32,
}

impl StyleCollector {
    fn new() -> Self {
        Self {
            fg_styles: HashMap::new(),
            counter: 1,
        }
    }

    fn add_fg(&mut self, color: Color) {
        if !self.fg_styles.contains_key(&color) {
            let class_name = format!("terminal-r{}", self.counter);
            self.fg_styles.insert(color, class_name);
            self.counter += 1;
        }
    }
}

/// Convert a crossterm Color to hex string.
fn color_to_hex(color: &Color) -> String {
    match color {
        Color::Rgb { r, g, b } => format!("#{:02x}{:02x}{:02x}", r, g, b),
        _ => "#000000".to_string(),
    }
}

/// Escape XML special characters.
fn escape_xml(s: &str) -> String {
    let mut result = String::with_capacity(s.len());
    for c in s.chars() {
        match c {
            '<' => result.push_str("&lt;"),
            '>' => result.push_str("&gt;"),
            '&' => result.push_str("&amp;"),
            '"' => result.push_str("&quot;"),
            '\'' => result.push_str("&apos;"),
            ' ' => result.push_str("&#160;"), // Non-breaking space for SVG
            _ => result.push(c),
        }
    }
    result
}

/// Build text-decoration CSS value from TextAttributes.
fn build_text_decoration(attrs: &TextAttributes) -> String {
    let mut decorations = Vec::new();
    if attrs.underline {
        decorations.push("underline");
    }
    if attrs.strike {
        decorations.push("line-through");
    }
    decorations.join(" ")
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_color_to_hex() {
        assert_eq!(color_to_hex(&Color::Rgb { r: 255, g: 0, b: 0 }), "#ff0000");
        assert_eq!(color_to_hex(&Color::Rgb { r: 0, g: 255, b: 0 }), "#00ff00");
        assert_eq!(color_to_hex(&Color::Rgb { r: 0, g: 0, b: 255 }), "#0000ff");
    }

    #[test]
    fn test_escape_xml() {
        assert_eq!(escape_xml("<test>"), "&lt;test&gt;");
        assert_eq!(escape_xml("a & b"), "a&#160;&amp;&#160;b");
    }
}
